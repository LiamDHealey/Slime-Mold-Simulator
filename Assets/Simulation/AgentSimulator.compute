// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SimulateAgents

struct Agent
{
    float2 position;
    float angle;
};

struct Sensor
{
    float angle;
    float distance;
    float turnSpeed;
};

RWTexture2D<float> Result;
RWStructuredBuffer<Agent> Agents;
RWStructuredBuffer<Sensor> Sensors;


float AgentSpeed;
float Time;
float2 MaxBounds;
int NumSensors;
float ForwardTurnSpeed;

#define PI 3.1415926535897932384626433


// Sudo random hash function from www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint RandomInt(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

uint RandomFloat(uint seed)
{
    return RandomInt(seed) / 4294967295.0;
}

float2 RandomAngle(uint seed)
{
    // Scale from 0 - MaxInt to -PI - PI
    return RandomInt(seed) * 0.000000001462918079607771839139298211247265334157646664629657 - PI;
}

uint GetSeed(uint3 id)
{
    return Agents[id.x].position.y + Agents[id.x].position.x + RandomInt(id.x + Time * 100000);
}

float GetSensorWeight(uint id, uint i)
{
    float angle = Sensors[i].angle + Agents[id].angle;
    float2 position = Agents[id].position + float2(cos(angle), sin(angle)) * Sensors[i].distance;
    return Result[position];
}

[numthreads(32, 1, 1)]
void SimulateAgents(uint3 id : SV_DispatchThreadID)
{
    // Turn Agents
    float forwardWeight = GetSensorWeight(id.x, 0);
    float greatestWeight = forwardWeight;
    int greatestIndex = -1;
    bool forwardLeast = true;
    for (int i = 1; i < NumSensors; i++)
    {
        float weight = GetSensorWeight(id.x, i);
        if (weight > greatestWeight)
        {
            greatestWeight = weight;
            greatestIndex = i;
        }
        if (weight < forwardWeight)
        {
            forwardLeast = false;
        }
    }
    
    if (forwardLeast)
    {
        float random = (RandomFloat(GetSeed(id)) - 0.5) * 2;
        Agents[id.x].angle += random * ForwardTurnSpeed;
    }
    else if (greatestIndex > 0)
    {
        Agents[id.x].angle += Sensors[greatestIndex].turnSpeed;
    }
    
    Result[Agents[id.x].position] = 1;
    
    
    
    
    // Move Agents
    float2 forward = float2(cos(Agents[id.x].angle), sin(Agents[id.x].angle));    
    Agents[id.x].position += forward * AgentSpeed;
    
    
    
    
    // Bounce Agents
    bool outOfBounds = 
        Agents[id.x].position.x < 0 || 
        Agents[id.x].position.x > MaxBounds.x || 
        Agents[id.x].position.y < 0 || 
        Agents[id.x].position.y > MaxBounds.y;
    
    if (outOfBounds)
    {
        Agents[id.x].angle = RandomAngle(GetSeed(id));
    }
    
    if (Agents[id.x].position.x < 0)
    {
        Agents[id.x].position.x *= -1;
    }
    else if (Agents[id.x].position.x > MaxBounds.x)
    {
        Agents[id.x].position.x = 2 * MaxBounds.x - Agents[id.x].position.x;
    }
    if (Agents[id.x].position.y < 0)
    {
        Agents[id.x].position.y *= -1;
    }
    else if (Agents[id.x].position.y > MaxBounds.y)
    {
        Agents[id.x].position.y = 2 * MaxBounds.y - Agents[id.x].position.y;
    }
}