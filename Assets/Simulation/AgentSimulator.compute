// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SimulateAgents

struct Agent
{
    float2 position;
    float angle;
};

struct Sensor
{
    float angle;
    float distance;
};

RWTexture2D<float> Result;
RWStructuredBuffer<Agent> Agents;
RWStructuredBuffer<Sensor> AgentSensors;


float AgentSpeed;
float Time;
float2 MaxBounds;

#define PI 3.1415926535897932384626433


// Sudo random hash function from www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint RandomInt(uint seed)
{
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}

float2 RandomAngle(uint seed)
{
    // Scale from 0 - MaxInt to -PI - PI
    return RandomInt(seed) * 0.000000001462918079607771839139298211247265334157646664629657 - PI;
}

uint GetSeed(uint3 id)
{
    return Agents[id.x].position.y + Agents[id.x].position.x + RandomInt(id.x + Time * 100000);
}

[numthreads(32, 1, 1)]
void SimulateAgents(uint3 id : SV_DispatchThreadID)
{
    // Bounce Agents
    float2 forward = float2(cos(Agents[id.x].angle), sin(Agents[id.x].angle));
    
    Agents[id.x].position += forward * AgentSpeed;
    bool outOfBounds = 
        Agents[id.x].position.x < 0 || 
        Agents[id.x].position.x > MaxBounds.x || 
        Agents[id.x].position.y < 0 || 
        Agents[id.x].position.y > MaxBounds.y;
    
    if (outOfBounds)
    {
        Agents[id.x].angle = RandomAngle(GetSeed(id));
    }
    
    if (Agents[id.x].position.x < 0)
    {
        Agents[id.x].position.x *= -1;
    }
    else if (Agents[id.x].position.x > MaxBounds.x)
    {
        Agents[id.x].position.x = 2 * MaxBounds.x - Agents[id.x].position.x;
    }
    if (Agents[id.x].position.y < 0)
    {
        Agents[id.x].position.y *= -1;
    }
    else if (Agents[id.x].position.y > MaxBounds.y)
    {
        Agents[id.x].position.y = 2 * MaxBounds.y - Agents[id.x].position.y;
    }
    
    
    Result[Agents[id.x].position] = 1;
}